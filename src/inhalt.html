<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
	"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
	<head profile="http://gmpg.org/xfn/11">
		<meta name="verify-v1" content="Pp/hN2d+Zab6K/3Kdral2QVk2FCkhyjOzq+g+necRzY=" />
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
		<title>
			Stefan Tilkov: REST und HTTP » Inhalt
		</title>
		<meta name="generator" content="WordPress 2.8.4" />
		<link rel="stylesheet" href="./css/style.css" type="text/css" media="screen" />
		<style type="text/css" media="screen">
		</style>
	</head>
	<body>
		<div id="wrapper">
			<div id="header"></div>
			<link rel="import" href="_topbar.html" />
			<div id="content" class="narrowcolumn">
				<div id="inner">
					<div class="post" id="post-3">
						<h1>
							Inhalt
						</h1>
						<div class="entry">
							<div id="content-summary">
								<ul>
									<li>
										<strong>Kapitel 1: Einleitung</strong> stellt die Motivation für den Einsatz von REST dar.
									</li>
									<li>
										<strong>Kapitel 2: Einführung in REST</strong> gibt einen kurzen Überblick die wesentlichen Grundprinzipien und Mechanismen von REST und RESTful HTTP.
									</li>
									<li>
										<strong>Kapitel 3: Fallstudie: OrderManager</strong> stellt anhand einer einfachen Bestellverwaltung vor, wie die Grundprinzipien von REST für eine einfache Anwendung eingesetzt werden können, die über HTTP programmatisch genutzt werden kann. Dabei liegt der Fokus nicht auf inhaltlicher Vollständigkeit oder technischer Raffinesse, sondern auf der Illustration der wesentlichen Konzepte.
									</li>
									<li>
										<strong>In Kapitel 4: Ressourcen</strong> beschäftigen wir uns mit dem abstrakten Konzept von Ressourcen und seiner konkreten Ausprägung im WWW. Neben der Identifikation mit Hilfe von URIs und der Einführung von Repräsentationen finden Sie hier auch Hinweise auf ein sinnvolles und REST-konformes Ressourcen- und URI-Design.
									</li>
									<li>
										<strong>Kapitel 5: Verben</strong> stellt das Abstrakte Konzept von Schnittstellen mit einem immer gleichen Satz von Operationen und die konkrete Ausprägung in HTTP vor. Neben den vordefinierten Verben aus dem HTTP-Standard werden auch einige aktuell in Diskussion befindliche neue sowie die Möglichkeit zur Definition eigener Verben beschrieben.
									</li>
									<li>
										<strong>Das Kapitel 6: Hypermedia</strong> spielt eine zentrale Rolle für das Verständnis von REST jenseits einfacher CRUD-Beispiele. Dahinter verbirgt sich das Konzept, Ressourcen miteinander zu verknüpfen, den Kontrollfluss einer Applikation dynamisch zu steuern und separat entwickelte Ressourcen unabhängig von ihrer Implementierungsstrategie oder ihrer Lokation zu kombinieren.
									</li>
									<li>
										<strong>Kapitel 7: Repräsentationsformate</strong> beschäftigt sich mit den Datenformaten, die in REST/HTTP-Anwendungen in der Regel zum Einsatz kommen. Dabei werden die Vor- und Nachteile verschiedener Formate diskutiert und Hinweise zu deren Anwendung geliefert.
									</li>
									<li>In <strong>Kapitel 8: Fallstudie: AtomPub</strong> finden Sie eine Beschreibung eines REST-konformen Protokolls zur Manipulation von Inhalten wie z.B. Einträgen in Weblogs oder Artikeln in einem CMS-System. Das Atom Publishing Protocol (AtomPub) ist ein offizieller Standard, der unter Beteiligung diverser Web-Experten und REST-Verfechter definiert wurde und daher in vielerlei Hinsicht der Musterknabe der REST-Familie ist.
									</li>
									<li>In <strong>Kapitel 9: Sitzungen und Skalierbarkeit</strong> erfahren Sie mehr über den Zusammenhang zwischen der Skalierbarkeit eines Systems und der Rolle, die der Verzicht auf eine sitzungsbehaftete Kommunikation dafür spielt. Thema sind neben der Motivation auch Empfehlungen, wie Sie einen Session-orientierten in einen Session-freien Entwurf überführen können.
									</li>
									<li>
										<strong>Kapitel 10: Caching</strong> beschäftigt sich mit der wichtigsten Performance-Optimierung im WWW und zeigt, wie Sie die beiden unterschiedlichen dafür vom HTTP-Protokoll unterstützten Verfahren – Validierungs- und Expirationsmodell – für Geschäftsanwendungen mit einer REST-Architektur nutzen können.
									</li>
									<li>
										<strong>Kapitel 11: Sicherheit</strong> gibt einen kurzen Abriss über die wesentlichen Sicherheitskonzepte im REST/HTTP-Umfeld und stellt neben allgemeinen Konzepten und den in HTTP integrierten Authentifizierungsmechanismen verschiedene Standards wie SSL, OpenID und OAuth vor.
									</li>
									<li>Das <strong>Kapitel 12: Dokumentation</strong> beschäftigt sich mit Strategien zur Dokumentation von REST-Anwendungen, auf Basis einfacher HTML-Seiten ebenso wie mit Hilfe von standardisierten Beschreibungssprachen wie WSDL, RDDL oder WADL.
									</li>
									<li>Thema von <strong>Kapitel 13: Erweiterte Anwendungsfälle</strong> sind asynchrone Verarbeitung, zuverlässige Zustellung, Transaktionen und die Konflikterkennung bei parallelen Zugriffen.
									</li>
									<li>In <strong>Kapitel 14: Fallstudie: OrderManager, Iteration 2</strong> erweitern wir unser Beispiel aus Kapitel 2 sowohl fachlich als auch technisch mit Hilfe des Wissens aus den Kapiteln 3-12, um Ihnen einen realistischen Eindruck von den typischen Entwurfsentscheidungen bei einer nicht-trivialen REST-Anwendung zu geben.
									</li>
									<li style="list-style: none">
										<strong>Kapitel 15: Architektur</strong> befasst sich mit den Auswirkungen, die sich aus dem Einsatz von REST und HTTP für unterschiedliche Architekturaspekte ergeben. Dazu zählen die Anwendungs- und Systemarchitektur, die Architektur von Benutzerschnittstellen, die interne Softwarearchitektur einzelner Systeme und die neuen Herausforderungen bei der Gestaltung von Web-APIs.
									</li>
									<li>
										<strong>Kapitel 16 „Enterprise REST“: SOA auf Basis von RESTful HTTP</strong> setzt die Konzepte von REST und die Technologien des Web in Beziehung zu Service-orientierten Architekturen (SOA) und zeigt, wie diese beiden Ansätze zusammen passen können. Darüber hinaus finden Sie hier eine Diskussion über die Vor- und Nachteile von Web-Services auf Basis von WSDL, SOAP und WS-* im Vergleich zu REST und HTTP.
									</li>
									<li>Im <strong>Anhang</strong> schließlich erfahren Sie mehr über die Werkzeuge, die Ihnen für eine konkrete Umsetzung einer REST/HTTP-basierten Lösung zur Verfügung stehen und finden eine Übersicht der HTTP-Statuscodes, eine Beschreibung einiger fortgeschrittener HTTP-Mechanismen wie Pipelining und persistente Sessions, einen Verweis auf diverse Online-Ressourcen mit weiterführenden Informationen, eine Liste der Referenzen sowie den Index.
									</li>
								</ul>
							</div>
							<div id="outline">
								<ul>
									<li>Vorwort
									</li>
									<li>Danksagung
									</li>
									<li>1 Einleitung
										<ul>
											<li>1.1 Warum REST?
												<ul>
													<li>1.1.1 Lose Kopplung
													</li>
													<li>1.1.2 Interoperabilität
													</li>
													<li>1.1.3 Wiederverwendung
													</li>
													<li>1.1.4 Performanz und Skalierbarkeit
													</li>
												</ul>
											</li>
											<li>1.2 Zielgruppe und Voraussetzungen
											</li>
											<li>1.3 Zur Struktur des Buches
											</li>
										</ul>
									</li>
									<li>2 Einführung in REST
										<ul>
											<li>2.1 Eine kurze Geschichte von REST
											</li>
											<li>2.2 Grundprinzipien
											</li>
											<li>2.3 Zusammenfassung
											</li>
										</ul>
									</li>
									<li>3 Fallstudie: OrderManager
										<ul>
											<li>3.1 Fachlicher Hintergrund
											</li>
											<li>3.2 Ressourcen
												<ul>
													<li>3.2.1 Bestellungen
													</li>
													<li>3.2.2 Bestellungen in unterschiedlichen Zuständen
													</li>
													<li>3.2.3 Stornierungen
													</li>
												</ul>
											</li>
											<li>3.3 Repräsentationen
											</li>
											<li>3.4 Zusammenfassung
											</li>
										</ul>
									</li>
									<li>4 Ressourcen
										<ul>
											<li>4.1 Ressourcen und Repräsentationen
											</li>
											<li>4.2 Ressourcen-Design
												<ul>
													<li>4.2.1 Primärressourcen
													</li>
													<li>4.2.2 Subressourcen
													</li>
													<li>4.2.3 Listen
														<ul>
															<li>4.2.3.1 Filter
															</li>
															<li>4.2.3.2 Paginierung
															</li>
														</ul>
													</li>
													<li>4.2.4 Projektionen
													</li>
													<li>4.2.5 Aggregationen
													</li>
													<li>4.2.6 Aktivitäten
													</li>
													<li>4.2.7 Konzeptressourcen
													</li>
													<li>4.2.8 Evolutionäre Weiterentwicklung und YAGNI
													</li>
												</ul>
											</li>
											<li>4.3 Ressourcenidentifikation und URIs
												<ul>
													<li>4.3.1 URI, IRI, URL, URN, XRI?
													</li>
													<li>4.3.2 Anatomie einer HTTP-URI
														<ul>
															<li>4.3.2.3 Schema und Host
															</li>
															<li>4.3.2.4 Relative und absolute Pfade
															</li>
															<li>4.3.2.5 Query-Parameter
															</li>
															<li>4.3.2.6 Matrix-Parameter
															</li>
															<li>4.3.2.7 Fragment-ID
															</li>
														</ul>
													</li>
													<li>4.3.3 URI-Templates
													</li>
												</ul>
											</li>
											<li>4.4 URI-Design
												<ul>
													<li>4.4.1 URI-Entwurfsgrundsätze
													</li>
													<li>4.4.2 REST aus Versehen
													</li>
													<li>4.4.3 Stabile URIs
													</li>
												</ul>
											</li>
											<li>4.5 Zusammenfassung
											</li>
										</ul>
									</li>
									<li>5 Verben
										<ul>
											<li>5.1 Standardverben von HTTP 1.1
												<ul>
													<li>5.1.1 GET
													</li>
													<li>5.1.2 HEAD
													</li>
													<li>5.1.3 PUT
													</li>
													<li>5.1.4 POST
													</li>
													<li>5.1.5 DELETE
													</li>
													<li>5.1.6 OPTIONS
													</li>
													<li>5.1.7 TRACE und CONNECT
													</li>
												</ul>
											</li>
											<li>5.2 HTTP-Verben in der Praxis
											</li>
											<li>5.3 Tricks für PUT und DELETE
												<ul>
													<li>5.3.1 HTML-Formulare
													</li>
													<li>5.3.2 Firewalls und eingeschränkte Clients
													</li>
												</ul>
											</li>
											<li>5.4 Definition eigener Methoden
												<ul>
													<li>5.4.1 WebDAV
													</li>
													<li>5.4.2 Partial Updates und PATCH
													</li>
													<li>5.4.3 Multi-Request-Verarbeitung und BATCH
													</li>
												</ul>
											</li>
											<li>5.5 Zusammenfassung
											</li>
										</ul>
									</li>
									<li>6 Hypermedia
										<ul>
											<li>6.1 Hypermedia im Browser
											</li>
											<li>6.2 HATEOAS und das „Human Web“
											</li>
											<li>6.3 Hypermedia in der Anwendung-zu-<br />
												Anwendungkommunikation
											</li>
											<li>6.4 Ressourcenverknüpfung
											</li>
											<li>6.5 Einstiegspunkte
											</li>
											<li>6.6 Aktionsrelationen
											</li>
											<li>6.7 Das Link-Element
											</li>
											<li>6.8 Standardisierung von Link-Relationen
											</li>
											<li>6.9 Zusammenfassung
											</li>
										</ul>
									</li>
									<li>7 Repräsentationsformate
										<ul>
											<li>7.1 Formate, Medientypen und Content-Negotiation
											</li>
											<li>7.2 XML
											</li>
											<li>7.3 HTML/XHTML
											</li>
											<li>7.4 Textformate
												<ul>
													<li>7.4.1 Plaintext
													</li>
													<li>7.4.2 URI-Listen
													</li>
												</ul>
											</li>
											<li>7.5 CSV
											</li>
											<li>7.6 JSON
											</li>
											<li>7.7 RSS und Atom
											</li>
											<li>7.8 Binäre Formate
											</li>
											<li>7.9 Microformats
											</li>
											<li>7.10 RDF
											</li>
											<li>7.11 Zusammenfassung
											</li>
										</ul>
									</li>
									<li>8 Fallstudie: AtomPub
										<ul>
											<li>8.1 Historie
											</li>
											<li>8.2 Discovery und Metadaten
											</li>
											<li>8.3 Ressourcentypen
											</li>
											<li>8.4 REST und Atom/AtomPub
											</li>
											<li>8.5 Zusamenfassung
											</li>
										</ul>
									</li>
									<li>9 Sitzungen und Skalierbarkeit
										<ul>
											<li>9.1 Cookies
											</li>
											<li>9.2 Ressourcen- und Client-Status
											</li>
											<li>9.3 Skalierbarkeit und „Shared Nothing“-Architektur
											</li>
											<li>9.4 Zusammenfassung
											</li>
										</ul>
									</li>
									<li>10 Caching
										<ul>
											<li>10.1 Expirationsmodell
											</li>
											<li>10.2 Validierungsmodell
											</li>
											<li>10.3 Cache-Topologien
											</li>
											<li>10.4 Caching und Header
												<ul>
													<li>10.4.1 Response-Header
													</li>
													<li>10.4.2 Request-Header
													</li>
												</ul>
											</li>
											<li>10.5 Schwache ETags
											</li>
											<li>10.6 Invalidierung
											</li>
											<li>10.7 Caching und personalisierte Inhalte
											</li>
											<li>10.8 Zusammenfassung
											</li>
										</ul>
									</li>
									<li>11 Sicherheit
										<ul>
											<li>11.1 SSL und HTTPS
											</li>
											<li>11.2 Authentisierung, Authentifizierung,<br />
												Autorisierung
											</li>
											<li>11.3 HTTP-Authentifizierung
											</li>
											<li>11.4 HTTP Basic Authentication
											</li>
											<li>11.5 Der 80%-Fall: HTTPS + Basic-Auth
											</li>
											<li>11.6 HTTP Digest Authentication
											</li>
											<li>11.7 Browser-Integration und Cookies
											</li>
											<li>11.8 HMAC
											</li>
											<li>11.9 OpenID
											</li>
											<li>11.10 OAuth
											</li>
											<li>11.11 Autorisierung
											</li>
											<li>11.12 Nachrichtenverschlüsselung und Signatur
											</li>
											<li>11.13 Zusammenfassung
											</li>
										</ul>
									</li>
									<li>12 Dokumentation
										<ul>
											<li>12.1 Selbstbeschreibende Nachrichten
											</li>
											<li>12.2 Hypermedia
											</li>
											<li>12.3 HTML als Standardformat
											</li>
											<li>12.4 Beschreibungsformate
												<ul>
													<li>12.4.1 WSDL
													</li>
													<li>12.4.2 WADL
													</li>
													<li>12.4.3 RDDL
													</li>
												</ul>
											</li>
											<li>12.5 Zusammenfassung
											</li>
										</ul>
									</li>
									<li>13 Erweiterte Anwendungsfälle
										<ul>
											<li>13.1 Asynchrone Verarbeitung
												<ul>
													<li>13.1.1 Notifikation per HTTP-„Callback“
													</li>
													<li>13.1.2 Polling
													</li>
												</ul>
											</li>
											<li>13.2 Reliable Messaging
												<ul>
													<li>13.2.1 PUT statt POST
													</li>
													<li>13.2.2 POST-PUT-Kombination
													</li>
													<li>13.2.3 Reliable POST
													</li>
												</ul>
											</li>
											<li>13.3 Transaktionen
												<ul>
													<li>13.3.1 Atomare (Datenbank-)Transaktionen
													</li>
													<li>13.3.2 Verteilte Transaktionen
													</li>
													<li>13.3.3 Fachliche Transaktionen
													</li>
												</ul>
											</li>
											<li>13.4 Parallelzugriff und konditionale Verarbeitung
											</li>
											<li>13.5 Versionierung
												<ul>
													<li>13.5.1 Zusätzliche Ressourcen
													</li>
													<li>13.5.2 Erweiterbare Datenformate
													</li>
													<li>13.5.3 Versionsabhängige Repräsentationen
													</li>
												</ul>
											</li>
											<li>13.6 Zusammenfassung
											</li>
										</ul>
									</li>
									<li>14 Fallstudie: OrderManager, Iteration 2
										<ul>
											<li>14.1 OrderEntry
												<ul>
													<li>14.1.1 Service-Dokumentation
													</li>
													<li>14.1.2 Medientypen
													</li>
													<li>14.1.1 Bestellpositionen
													</li>
												</ul>
											</li>
											<li>14.2 Fulfilment
												<ul>
													<li>14.2.1 Notifikation über neue Bestellungen
													</li>
													<li>14.2.2 Bestellübernahme
													</li>
													<li>14.2.3 Produktionsaufträge
													</li>
													<li>14.2.4 Versandfristen
													</li>
													<li>14.2.5 Lieferdatum
													</li>
												</ul>
											</li>
											<li>14.3 Reporting
											</li>
											<li>14.4 Zusammenfassung
											</li>
										</ul>
									</li>
									<li>15 Architektur und Umsetzung
										<ul>
											<li>15.1 Architekturebenen
											</li>
											<li>15.2 Anwendungsarchitektur
												<ul>
													<li>15.2.1 Sytemgrenzen und Ressourcen
													</li>
													<li>15.2.2 Medientypen und Kontrakte
													</li>
													<li>15.2.3 Indentität und Adressierbarkeit
													</li>
												</ul>
											</li>
											<li>15.3 Softwarearchitektur
												<ul>
													<li>15.3.1 Schichten
													</li>
													<li>15.3.2 Domänenmodell
													</li>
													<li>15.3.3 Nutzung von Diensten
													</li>
												</ul>
											</li>
											<li>15.4 Systemarchitektur
												<ul>
													<li>15.4.1 Netzopologie
													</li>
													<li>15.4.2 Caching
													</li>
													<li>15.4.3 Firewalls
													</li>
												</ul>
											</li>
											<li>15.5 Fronted-Architektur
												<ul>
													<li>15.5.1 Benutzerschnittstellen und RESTful-HTTP-Backends
													</li>
													<li>15.5.2 Sinn und Unsinn von Portalen
													</li>
												</ul>
											</li>
											<li>15.6 Web-API-Architektur
											</li>
											<li>15.7 Zusammenfassung
											</li>
										</ul>
									</li>
									<li>16 „Enterprise REST“:<br />
										SOA auf Basis von RESTful HTTP
										<ul>
											<li>16.1 SOA-Definitionen
											</li>
											<li>16.2 Business/IT-Alignment
											</li>
											<li>16.3 Governance
												<ul>
													<li>16.3.1 Daten- und Schnittstellenbeschreibungen
													</li>
													<li>16.3.2 Registry/Repository-Lösungen
													</li>
													<li>16.3.3 Discovery
													</li>
												</ul>
											</li>
											<li>16.4 Orchestrierung und Choreographie
											</li>
											<li>16.5 Enterprise Service Bus (ESB)
											</li>
											<li>16.6 WSDL, SOAP &amp; WS-*: WS-Architektur
											</li>
											<li>16.7 Zusammenfassung
											</li>
										</ul>
									</li>
									<li>Anhang
										<ul>
											<li>A: HTTP-Statuscodes
											</li>
											<li>B: Fortgeschrittene HTTP-Mechanismen
												<ul>
													<li>B.1 Persistente Verbindungen
													</li>
													<li>B.2 Request-Pipelining
													</li>
													<li>B.3 Range Requests
													</li>
													<li>B.4 Chunked Encoding
													</li>
												</ul>
											</li>
											<li>C: Werkzeuge und Bibliotheken
												<ul>
													<li>C.1 Kommandozeilen-Clients
													</li>
													<li>C.2 HTTP-Server
													</li>
													<li>C.3 Caches
													</li>
													<li>C.4 Programmierumgebungen
														<ul>
															<li>C.4.1 Java
															</li>
															<li>C.4.2 Microsoft .NET
															</li>
															<li>C.4.3 Ruby und Ruby on Rails
															</li>
															<li>C.4.4 Python, Perl &amp; Co
															</li>
														</ul>
													</li>
													<li>D: Referenzen
													</li>
												</ul>
											</li>
										</ul>
									</li>
								</ul>
							</div>
								<link rel="import" href="_footer.html" />
								<link rel="import" href="_analytics.html" />
						</div>
					</div>
				</div>
			</div>
		</div>
	</body>
</html>
